<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>B·∫£n ƒë·ªì tr·ªìng tr·ªçt - Ho√† Ph√°t Qu·∫£ng B√¨nh</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <link rel="apple-touch-icon" sizes="192x192" href="https://github.com/ducmanhtran/trong-trot-test/blob/main/icon1.png?raw=true">
  <link rel="icon" type="image/png" sizes="192x192" href="https://github.com/ducmanhtran/trong-trot-test/blob/main/icon1.png?raw=true">
    <!-- Leaflet Locate CSS & JS (CDN) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.locatecontrol/dist/L.Control.Locate.min.css" />
  <script src="https://unpkg.com/leaflet.locatecontrol/dist/L.Control.Locate.min.js"></script>
  <style>
/* ===== MENU ===== */
#menu{background:linear-gradient(90deg,#007bff,#0056b3);box-shadow:0 2px 6px rgba(0,0,0,0.25);position:relative;z-index:1000;font-family:Arial,sans-serif}
#menu .menu{list-style:none;margin:0;padding:0;display:flex;justify-content:center}
#menu .menu>li{position:relative}
#menu button{background:none;border:none;padding:14px 20px;font-size:15px;color:#fff;font-weight:600;cursor:pointer;transition:background .3s;display:flex;align-items:center;gap:6px}
#menu button:hover{background:rgba(0,0,0,0.05);color:#007bff}
#menu .submenu{display:none;position:absolute;top:100%;left:0;background:#fff;list-style:none;margin:0;padding:6px 0;box-shadow:0 2px 6px rgba(0,0,0,0.25);min-width:200px;border-radius:4px}
#menu .submenu li{text-align:left}
#menu .submenu button{width:100%;text-align:left;padding:10px 14px;font-size:14px;color:#333;background:none;border:none}
#menu .submenu button:hover{background:#f0f0f0;color:#007bff}
#menu .menu>li:hover>.submenu{display:block}
#menu .submenu label{font-size:14px;color:#333;display:block;cursor:pointer}
@media(max-width:768px){
  /* move info box up for mobile */
  #infoBox{bottom:80px;left:5px;font-size:13px;padding:6px 10px}

  /* --- HAMBURGER: hi·ªán tr√™n mobile, n·ªÅn xanh + 3 g·∫°ch tr·∫Øng --- */
  .hamburger-btn{
    display:block;
    position:fixed;      /* ‚úÖ c·ªë ƒë·ªãnh tr√™n m√†n h√¨nh */
    left:10px; top:8px;
    z-index:1100;
    background:#007bff;
    color:#fff;
    border:none;
    border-radius:6px;
    padding:8px 12px;
    font-size:22px;
    cursor:pointer;
    box-shadow:0 2px 4px rgba(0,0,0,0.3);
  }

  #menu .menu{
    /* th√™m kho·∫£ng tr·ªëng ph√≠a tr√™n ƒë·ªÉ kh√¥ng ƒë√® n√∫t */
    margin-top:60px;      /* ‚úÖ t·∫°o kho·∫£ng c√°ch */
    display:none;
    grid-template-columns:1fr;
    grid-gap:4px;
    padding:8px;
    border-radius:6px;
    background:rgba(255,255,255,0.95);
    box-shadow:0 2px 6px rgba(0,0,0,0.12);
  }
    #menu .menu.show{
    display: grid; /* ho·∫∑c block */
  }
}
/* ===== MAP + FOOTER ===== */
#map{height:calc(100vh - 100px);width:100%;margin:0;padding:0}
#footerTitle{position:fixed;bottom:0;left:0;width:100%;margin:0;padding:4px 6px;background:rgba(255,255,255,0.85);text-align:center;font-size:13px;box-shadow:0 -1px 4px rgba(0,0,0,0.15);z-index:1000}
/* ===== LABEL & TOGGLE ===== */
.custom-label{font-weight:200;font-size:13px;color:#000;text-align:center;white-space:nowrap}
.toggle-labels-btn, .toggle-color-btn{background:#fff;border:1px solid #bbb;border-radius:6px;padding:6px 10px;font-size:14px;cursor:pointer;box-shadow:0 2px 4px rgba(0,0,0,0.15);margin-bottom:40px}
.toggle-labels-btn:hover, .toggle-color-btn:hover{background:#f0f0f0}
#infoBox{position:fixed;bottom:40px;left:10px;background:rgba(255,255,255,0.9);border:1px solid #ccc;padding:8px 12px;font-size:14px;font-weight:bold;border-radius:6px;box-shadow:0 2px 6px rgba(0,0,0,0.2);z-index:1200;display:none}
/* ===== TASK PANEL ===== */
#taskPanel{position:fixed;top:60px;right:10px;width:280px;background:rgba(255,255,255,0.95);border:1px solid #ccc;padding:10px;border-radius:6px;box-shadow:0 2px 6px rgba(0,0,0,0.2);z-index:1200;display:none}
#taskPanel label{font-weight:bold}
#taskList{max-height:300px;overflow:auto;font-size:14px;margin-top:6px}
#taskPanel .task-content{max-height:250px;overflow:auto;padding:10px 14px;font-size:14px;line-height:1.4}
#taskPanel .date-label{display:block;margin:8px 14px 4px;font-weight:bold}
#taskDate{width:calc(100% - 28px);margin:0 14px 12px;padding:6px 8px;border:1px solid #ccc;border-radius:6px}
@media (max-width:768px){
  #taskPanel{top:10px;left:50%;transform:translateX(-50%);width:80%}
}
#taskPanel .panel-header{position:relative;padding-right:35px}
#closeTasksBtn{position:absolute;top:0;right:0;background:none;border:none;font-size:18px;cursor:pointer;line-height:1}
.lot-item:hover{cursor:pointer;background:#f9f9f9}
#menu .submenu li label{font-family:inherit;font-size:14px;font-weight:600;line-height:1.4;display:flex;align-items:center;gap:6px}
#menu .submenu li label input[type="checkbox"]{transform:scale(1.1);margin:0}
@media (min-width:769px){
  .hamburger-btn{
    display:none !important;
    visibility:hidden !important;
  }
}
@media (max-width:768px){
  #menu .submenu{
    position: static;       /* ‚ùó kh√¥ng d√πng absolute tr√™n mobile */
    display: none;          /* ·∫©n m·∫∑c ƒë·ªãnh */
    margin: 0;              /* b·ªè margin th·ª´a */
    padding-left: 12px;     /* t·∫°o kho·∫£ng c√°ch l√πi v√†o n·∫øu mu·ªën */
    background: rgba(255,255,255,0.95);
    box-shadow: none;       /* b·ªè b√≥ng n·∫øu kh√¥ng c·∫ßn */
  }
  /* khi li c√≥ class open th√¨ hi·ªán submenu */
  #menu .menu > li.open > .submenu{
    display: block;
  }

  /* c√≥ th·ªÉ tu·ª≥ ch·ªânh th√™m kho·∫£ng c√°ch gi·ªØa c√°c li */
  #menu .menu > li{
    margin-bottom: 4px;
  }
  #menu .submenu li button {
   padding-left: 20px;
  }
  #hamburger {
  color: blue !important;          /* ch·ªØ xanh d∆∞∆°ng m·∫∑c ƒë·ªãnh */
  }
  #hamburger:hover {
  color: darkblue !important;
  }
  #menu .menu > li > button {
  color: blue !important;
  }
/* M·∫∑c ƒë·ªãnh tr√™n m·ªçi thi·∫øt b·ªã */
}
.pipe-label {
  font-weight: bold;
  color: #0000ff;              /* m√†u ch·ªØ d·ªÖ nh√¨n */
  background: rgba(255,255,255,0.7);
  border: none;
  box-shadow: none;
  font-size: 14px;
}
.leaflet-tooltip.pipe-label { opacity:0; }
/* ·∫®n ho√†n to√†n icon g·ªëc c·ªßa plugin */
.leaflet-control-locate.leaflet-bar a::before,
.leaflet-control-locate a::before {
    content: none !important;
    background: none !important;
    box-shadow: none !important; /* ph√≤ng khi plugin d√πng shadow cho icon */
}
.leaflet-control-locate a::after {
    content: "";
    width: 18px;
    height: 18px;
    background: url('https://github.com/ducmanhtran/trong-trot-test/blob/main/arrow-blue.svg') center/contain no-repeat;
    display: block;
}
#irrigationButtons {
    position: absolute;
    top: 10px;       /* v·ªã tr√≠ m·∫∑c ƒë·ªãnh cho desktop */
    right: 10px;
    z-index: 1000;
}

/* üëâ Khi tr√™n ƒëi·ªán tho·∫°i (m√†n h√¨nh nh·ªè) */
@media (max-width: 768px) {
  #irrigationButtons {
    top: 10px;                 /* kho·∫£ng c√°ch t·ª´ vi·ªÅn tr√™n */
    left: 50%;                 /* canh gi·ªØa theo chi·ªÅu ngang */
    transform: translateX(-50%); /* d·ªãch l·∫°i 1/2 chi·ªÅu r·ªông ƒë·ªÉ ƒë√∫ng ch√≠nh gi·ªØa */
    right: auto;               /* b·ªè ƒë·ªãnh v·ªã right */
    display: flex;             /* ƒë·ªÉ x·∫øp hai n√∫t theo chi·ªÅu ngang */
    gap: 8px;                  /* kho·∫£ng c√°ch gi·ªØa 2 n√∫t */
  }
.leaflet-control-layers.leaflet-control {
  position: absolute !important;  /* ghi ƒë√® v·ªã tr√≠ m·∫∑c ƒë·ªãnh */
  left: 120px;         
  bottom: 0px !important;  
  min-width: 110px;       /* b·∫£ng s·∫Ω lu√¥n ‚â• 180px */
  width: 110px !important;/* ho·∫∑c d√πng h·∫≥n width c·ªë ƒë·ªãnh n·∫øu mu·ªën */
}
#btnTogglePanels {
  position: bottomright;
  bottom: 10px;
  right: 10px;
  z-index: 1000;
  background: white;
  padding: 6px 10px;
  border-radius: 6px;
  border: 1px solid #ccc;
}


</style>
</head>
<body>
<button class="hamburger-btn" id="hamburger" aria-label="M·ªü menu" aria-expanded="false">‚ò∞</button>
<nav id="menu" aria-label="Main menu">
  <ul class="menu">
    <li>
      <button aria-haspopup="true">üå± C√¢y tr·ªìng ‚ñæ</button>
      <ul class="submenu">
        <li><button data-crop="all" class="final-item" >üåç T·ªïng th·ªÉ</button></li>
        <li><button data-crop="C·ªè" class="final-item">üå± C·ªè</button></li>
        <li><button data-crop="Ng√¥" class="final-item">üåΩ Ng√¥</button></li>
        <li><button data-crop="S·∫Øn" class="final-item">ü•î S·∫Øn</button></li>
        <li><button data-crop="ƒê·∫•t tr·ªëng" class="final-item">‚¨ú ƒê·∫•t tr·ªëng</button></li>
      </ul>
    </li>
    <li>
      <button aria-haspopup="true">üõ†Ô∏è C√¥ng vi·ªác ‚ñæ</button>
      <ul class="submenu">
        <li><button id="dailyTaskBtn" class="final-item">üìÖ C√¥ng vi·ªác h√†ng ng√†y</button></li>
      </ul>
    </li>
    <li>
      <button aria-haspopup="true">üèóÔ∏è H·∫° t·∫ßng ‚ñæ</button>
      <ul class="submenu">
        <li><button id="btnIrrigation" class="final-item">üíß H·ªá th·ªëng t∆∞·ªõi</button></li>
        <li><button class="final-item">üöú M√°y m√≥c</button></li>
      </ul>
    </li>
    <li>
      <button aria-haspopup="true">üìú Ph√°p l√Ω ‚ñæ</button>
      <ul class="submenu">
        <li><label><input type="checkbox" id="chkCompanyLegal" class="final-item"> S·ªï ƒë·ªè c√¥ng ty</label></li>
        <li><label><input type="checkbox" id="chkActualLots" class="final-item"> Hi·ªán tr·∫°ng</label></li>
        <li><label><input type="checkbox" id="chkDisputed" class="final-item"> ƒê·∫•t l·∫•n chi·∫øm</label></li>
      </ul>
    </li>
  </ul>
</nav>

<div id="map"> <div id="infoBox"></div> </div>
<h2 id="footerTitle">B·∫£n ƒë·ªì tr·ªìng tr·ªçt H√≤a Ph√°t Qu·∫£ng B√¨nh</h2>


<div id="taskPanel" role="dialog" aria-labelledby="taskPanelTitle">
  <div class="panel-header">
    <span id="taskPanelTitle">C√¥ng vi·ªác h√†ng ng√†y</span>
    <button id="closeTasksBtn" aria-label="ƒê√≥ng">‚úñ</button>
  </div>
  <div id="taskList" class="task-content"></div>
  <label for="taskDate" class="date-label">Ch·ªçn ng√†y:</label>
  <input type="date" id="taskDate">
</div>
<div id="irrigationButtons"style="display:none;">
  <button id="btnTogglePipeLabel">Hi·ªán nh√£n ·ªëng</button>
  <button id="btnTogglePebLabel">Hi·ªán t√™n PEB</button>
</div>
 <button id="btnTogglePanels">üìë Hi·ªán b·∫£ng</button>
<script>
window.onload = function () {
  // URLs
  const sheetCropsUrl = "https://docs.google.com/spreadsheets/d/13II_ZFEvrxK2qd0mkIX-0TNPdUH5ac4NFykmjqEPCZM/gviz/tq?tqx=out:json";
  const sheetTaskUrl = "https://docs.google.com/spreadsheets/d/13II_ZFEvrxK2qd0mkIX-0TNPdUH5ac4NFykmjqEPCZM/gviz/tq?tqx=out:json&gid=693737777";
  const sheetLegalUrl = "https://docs.google.com/spreadsheets/d/1yLzyQRiZjOxwXDNL2gKtzTULA9ODTcS0bLXTOxqELBE/gviz/tq?tqx=out:json";
  const sheetDisputedUrl = "https://docs.google.com/spreadsheets/d/1yLzyQRiZjOxwXDNL2gKtzTULA9ODTcS0bLXTOxqELBE/gviz/tq?tqx=out:json&gid=162449209";

  // state
  let rowsData = [];
  let polygons = [];
  let colorHidden = false;          // tr·∫°ng th√°i ·∫©n m√†u
  let originalStyles = new Map();   // l∆∞u style g·ªëc c·ªßa t·ª´ng polygon
  let labelsVisible = false;
  let taskData = [];
  let highlightLayers = [];

  const cropsByName = {};
  const actualByName = {};
  const legalByName = {};
  const disputedByName = {};

  // map + groups
  const map = L.map('map', { center: [17.5089721, 106.4670833], zoom: 13, zoomControl: false });
  L.control.zoom({ position: 'bottomright' }).addTo(map);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' }).addTo(map);
  L.control.locate({
    position: 'topright',        // v·ªã tr√≠ n√∫t tr√™n b·∫£n ƒë·ªì: 'topleft','topright','bottomleft','bottomright'
    strings: {
        title: "ƒê·ªãnh v·ªã v·ªá tinh" // tooltip khi r√™ chu·ªôt
    },
    flyTo: true,                // map t·ª± ƒë·ªông bay (animate) ƒë·∫øn v·ªã tr√≠
    keepCurrentZoomLevel: false,// zoom ƒë·∫øn m·ª©c ph√π h·ª£p v·ªõi ƒë·ªô ch√≠nh x√°c GPS
    showPopup: true,            // hi·ªán popup v·ªõi ƒë·ªô ch√≠nh x√°c
    locateOptions: {
        enableHighAccuracy: true // b·∫≠t GPS ch√≠nh x√°c cao (n·∫øu thi·∫øt b·ªã h·ªó tr·ª£)
    }
  }).addTo(map);
  let pipeLabelVisible = false;
  let pebLabelVisible = false;
  const cropsGroup = L.layerGroup().addTo(map);
  const companyLegalGroup = L.layerGroup();
  const actualLotsGroup = L.layerGroup();
  const disputedGroup = L.layerGroup();
  const highlightGroup = L.layerGroup().addTo(map);
  const irrigationGroup = L.layerGroup(); // nh√≥m H·ªá th·ªëng t∆∞·ªõi
  irrigationGroup.remove(); // ·∫®n m·∫∑c ƒë·ªãnh

  // toggle nh√£n
  const toggleBtn = L.control({ position: 'bottomright' });
  toggleBtn.onAdd = function () {
    const btn = L.DomUtil.create('button', 'toggle-labels-btn');
    btn.innerHTML = 'üëÅÔ∏è Hi·ªán nh√£n';
    btn.onclick = function () {
      labelsVisible = !labelsVisible;
      polygons.forEach(p => { if (p.myTooltip) { if (labelsVisible) map.addLayer(p.myTooltip); else map.removeLayer(p.myTooltip); } });
      btn.innerHTML = labelsVisible ? 'üôà ·∫®n nh√£n' : 'üëÅÔ∏è Hi·ªán nh√£n';
    };
    return btn;
  };
  toggleBtn.addTo(map);
  // toggle m√†u
  const toggleColorBtn = L.control({ position: 'bottomright' });
  toggleColorBtn.onAdd = function () {
    const btn = L.DomUtil.create('button', 'toggle-color-btn');
    btn.innerHTML = 'üé® ·∫®n m√†u';
    btn.onclick = function () {
      colorHidden = !colorHidden;
  
      polygons.forEach(p => {
        if (colorHidden) {
          // l∆∞u style g·ªëc n·∫øu ch∆∞a c√≥
          if (!originalStyles.has(p)) {
            originalStyles.set(p, {
              color: p.options.color,
              weight: p.options.weight,
              fillColor: p.options.fillColor,
              fillOpacity: p.options.fillOpacity
            });
          }
          // √°p style x√°m
          p.setStyle({
            color: "#CCFFCC",       // vi·ªÅn xanh lam m·ªèng
            weight: 0.5,
            fillColor: "#CCFFCC",
            fillOpacity: 0.6
          });
        } else {
          // kh√¥i ph·ª•c style g·ªëc
          const st = originalStyles.get(p);
          if (st) p.setStyle(st);
        }
      });
  
      btn.innerHTML = colorHidden ? 'üé® Hi·ªán m√†u' : 'üé® ·∫®n m√†u';
    };
    return btn;
  };
  toggleColorBtn.addTo(map);

  // helpers parse
  function parseDate_fromSheet(str) {
    if (!str) return null;
    str = String(str).trim();
    if (str.includes('/')) {
      const parts = str.split('/');
      if (parts.length === 3) return new Date(parts[2], parts[1] - 1, parts[0]);
    }
    const match = str.match(/Date\((\d+),(\d+),(\d+)\)/);
    if (match) return new Date(+match[1], +match[2], +match[3]);
    const d = new Date(str); return isNaN(d) ? null : d;
  }
  function parseTaskDate(dateStr) { if (!dateStr) return null; const m = dateStr.match(/Date\((\d+),(\d+),(\d+)\)/); if (m) return new Date(+m[1], +m[2], +m[3]); const d = new Date(dateStr); return isNaN(d) ? null : d; }

  // draw crops
  function drawCrops(filterCrop) {
    labelsVisible = false;
    document.querySelector('.toggle-labels-btn').innerHTML = 'üëÅÔ∏è Hi·ªán nh√£n';
    polygons.forEach(p => { if (p.myTooltip) map.removeLayer(p.myTooltip); });
    cropsGroup.clearLayers(); polygons = []; Object.keys(cropsByName).forEach(k => delete cropsByName[k]);

    const today = new Date();
    let totalGrassArea = 0, totalCassavaArea = 0, totalCornArea = 0;

    rowsData.forEach(row => {
      const [name, areaRaw, crop, stage, dateStr, coordsStr] = row.c.map(c => c?.v);
      const area = parseFloat(areaRaw) || 0;
      if (!coordsStr) return; if (filterCrop !== 'all' && crop !== filterCrop) return;
      let coords;
      try { coords = JSON.parse(coordsStr); } catch (e) { return; }

      let color = 'blue', fillColor = 'gray', fillOpacity = 0.6, weight = 0.5;
      const plantDate = parseDate_fromSheet(dateStr);
      const monthsElapsed = plantDate ? ((today - plantDate) / (1000 * 60 * 60 * 24 * 30)) : 0;

      if (filterCrop === 'all') {
        if (crop === 'C·ªè') fillColor = 'yellow';
        else if (crop === 'Ng√¥') fillColor = 'orange';
        else if (crop === 'S·∫Øn') fillColor = 'green';
        else if (crop === 'ƒê·∫•t tr·ªëng') { fillColor = 'brown'; fillOpacity = 0.3; }
      } else {
        if (crop === 'C·ªè') { fillColor = 'yellow'; if (monthsElapsed >= 3) { color = 'red'; weight = 2; totalGrassArea += area; } fillOpacity = Math.min(1, monthsElapsed / 6); }
        else if (crop === 'S·∫Øn') { fillColor = 'green'; if (monthsElapsed >= 10) { color = 'red'; weight = 2; totalCassavaArea += area; } fillOpacity = Math.min(1, monthsElapsed / 6 * 3 / 10); }
        else if (crop === 'Ng√¥') { fillColor = 'orange'; if (monthsElapsed >= 6) { color = 'red'; weight = 2; totalCornArea += area; } fillOpacity = Math.min(1, monthsElapsed / 6 * 3 / 6); }
        else if (crop === 'ƒê·∫•t tr·ªëng') { fillColor = 'brown'; fillOpacity = 0.3; }
      }

      const poly = L.polygon(coords, { color, weight, fillColor, fillOpacity }).addTo(cropsGroup);
      poly.options.name = name;
      const displayDate = plantDate ? `${plantDate.getDate()}/${plantDate.getMonth() + 1}/${plantDate.getFullYear()}` : 'Ch∆∞a c√≥';
      poly.bindPopup(`<b>${name}</b><br>Di·ªán t√≠ch: ${area} ha<br>C√¢y: ${crop}<br>Giai ƒëo·∫°n: ${stage}<br>Ng√†y: ${displayDate}`);
      poly.myTooltip = L.tooltip({ permanent: true, direction: 'center', className: 'custom-label' })
        .setContent(`${name}<br>${area} ha`).setLatLng(poly.getBounds().getCenter());

      polygons.push(poly);
      if (name) cropsByName[String(name)] = poly;
    });

    const box = document.getElementById('infoBox');
    if (filterCrop === 'C·ªè') { box.style.display = 'block'; box.innerText = `üå± C·ªè ƒë·∫øn h·∫°n thu ho·∫°ch: ${totalGrassArea.toFixed(2)} ha`; }
    else if (filterCrop === 'S·∫Øn') { box.style.display = 'block'; box.innerText = `ü•î S·∫Øn ƒë·∫øn h·∫°n thu ho·∫°ch: ${totalCassavaArea.toFixed(2)} ha`; }
    else if (filterCrop === 'Ng√¥') { box.style.display = 'block'; box.innerText = `üåΩ Ng√¥ ƒë·∫øn h·∫°n thu ho·∫°ch: ${totalCornArea.toFixed(2)} ha`; }
    else { box.style.display = 'none'; }
  }

  // fetch crops
  fetch(sheetCropsUrl).then(r => r.text()).then(data => {
    const match = data.match(/google\.visualization\.Query\.setResponse\((.*)\);/s);
    if (!match) { console.error('Kh√¥ng parse ƒë∆∞·ª£c d·ªØ li·ªáu crops'); return; }
    try { rowsData = JSON.parse(match[1]).table.rows; drawCrops('all'); } catch (e) { console.error('L·ªói parse crops', e); }
  }).catch(e => console.error('L·ªói fetch crops', e));

  // company legal
  function drawCompanyLegal() {
    Object.keys(legalByName).forEach(k => delete legalByName[k]); companyLegalGroup.clearLayers();
    fetch(sheetLegalUrl).then(r => r.text()).then(txt => {
      const match = txt.match(/google\.visualization\.Query\.setResponse\((.*)\);/s);
      if (!match) return;
      const rows = JSON.parse(match[1]).table.rows;
      rows.forEach(r => {
        const [stt, name, areaRaw, coordsStr, note] = r.c.map(c => c?.v);
        if (!coordsStr) return; let coords; try { coords = JSON.parse(coordsStr); } catch (e) { return; }
        const poly = L.polygon(coords, { color: 'blue', weight: 1, fillColor: '#add8e6', fillOpacity: 0.4 }).addTo(companyLegalGroup);
        poly.bindPopup(`<b>${name}</b><br>Di·ªán t√≠ch: ${areaRaw || ''} ha<br>${note ? note : ''}`);
        if (name) legalByName[String(name)] = poly;
      });
    }).catch(err => console.error('L·ªói fetch s·ªï ƒë·ªè:', err));
  }

  // actual lots
  function drawActualLots() {
    Object.keys(actualByName).forEach(k => delete actualByName[k]); actualLotsGroup.clearLayers();
    rowsData.forEach(r => {
      const [name, areaRaw, crop, stage, dateStr, coordsStr] = r.c.map(c => c?.v);
      if (!coordsStr) return; let coords; try { coords = JSON.parse(coordsStr); } catch (e) { return; }
      const poly = L.polygon(coords, { color: 'green', weight: 1, fillColor: '#b0f2b6', fillOpacity: 0.4 }).addTo(actualLotsGroup);
      poly.bindPopup(`<b>${name}</b><br>${areaRaw} ha`);
      if (name) actualByName[String(name)] = poly;
    });
  }

  // disputed lots
  function drawDisputedLots() {
    Object.keys(disputedByName).forEach(k => delete disputedByName[k]); disputedGroup.clearLayers();
    fetch(sheetDisputedUrl).then(r => r.text()).then(txt => {
      const match = txt.match(/google\.visualization\.Query\.setResponse\((.*)\);/s);
      if (!match) return; const rows = JSON.parse(match[1]).table.rows;
      rows.forEach(r => {
        const [stt, name, areaRaw, coordsStr, note] = r.c.map(c => c?.v);
        if (!coordsStr) return; let coords; try { coords = JSON.parse(coordsStr); } catch (e) { return; }
        const poly = L.polygon(coords, { color: 'red', weight: 2, fillColor: '#f5b7b1', fillOpacity: 0.5 }).addTo(disputedGroup);
        poly.bindPopup(`<b>${name}</b><br>Di·ªán t√≠ch: ${areaRaw || ''} ha<br>${note ? note : ''}`);
        if (name) disputedByName[String(name)] = poly;
      });
    }).catch(err => console.error('L·ªói fetch disputed:', err));
  }

  function anyLegalChecked() {
    return document.getElementById('chkCompanyLegal').checked || document.getElementById('chkActualLots').checked || document.getElementById('chkDisputed').checked;
  }

  // checkbox events
  document.getElementById('chkCompanyLegal').addEventListener('change', function () {
    if (this.checked) { if (map.hasLayer(cropsGroup)) map.removeLayer(cropsGroup); highlightGroup.clearLayers(); drawCompanyLegal(); map.addLayer(companyLegalGroup); }
    else { companyLegalGroup.clearLayers(); map.removeLayer(companyLegalGroup); if (!anyLegalChecked()) map.addLayer(cropsGroup); }
  });
  document.getElementById('chkActualLots').addEventListener('change', function () {
    if (this.checked) { if (map.hasLayer(cropsGroup)) map.removeLayer(cropsGroup); highlightGroup.clearLayers(); drawActualLots(); map.addLayer(actualLotsGroup); }
    else { actualLotsGroup.clearLayers(); map.removeLayer(actualLotsGroup); if (!anyLegalChecked()) map.addLayer(cropsGroup); }
  });
  document.getElementById('chkDisputed').addEventListener('change', function () {
    if (this.checked) { if (map.hasLayer(cropsGroup)) map.removeLayer(cropsGroup); highlightGroup.clearLayers(); drawDisputedLots(); map.addLayer(disputedGroup); }
    else { disputedGroup.clearLayers(); map.removeLayer(disputedGroup); if (!anyLegalChecked()) map.addLayer(cropsGroup); }
  });

  // fetch tasks
  fetch(sheetTaskUrl).then(res => res.text()).then(data => {
    const match = data.match(/google\.visualization\.Query\.setResponse\((.*)\);/s);
    if (match) taskData = JSON.parse(match[1]).table.rows;
  }).catch(e => console.error('L·ªói fetch tasks:', e));

  function clearHighlights() { highlightGroup.clearLayers(); highlightLayers = []; }

  // show tasks
  function showTasks() {
    if (!taskDateInput.value) return;
    const selectedDate = new Date(taskDateInput.value);
    selectedDate.setHours(0,0,0,0);
    document.getElementById('taskPanelTitle').textContent = 'C√¥ng vi·ªác ng√†y ' + String(selectedDate.getDate()).padStart(2,'0') + '/' + String(selectedDate.getMonth() + 1).padStart(2,'0') + '/' + selectedDate.getFullYear();

    clearHighlights();

    const dayTasks = taskData.filter(row => { const [stt, dateStr] = row.c.map(c => c?.v); const d = parseTaskDate(dateStr); return d && d.toDateString() === selectedDate.toDateString(); });

    taskListDiv.innerHTML = '';
    const lotTasksMap = {};
    dayTasks.forEach(row => { const [stt, dateStr, lot, content, quantity] = row.c.map(c => c?.v); if (!lot) return; if (!lotTasksMap[lot]) lotTasksMap[lot] = []; lotTasksMap[lot].push({ content, quantity }); });

    Object.keys(lotTasksMap).forEach(lot => {
      const poly = cropsByName[lot] || actualByName[lot] || legalByName[lot] || disputedByName[lot];
      if (poly) {
        const highlight = L.polygon(poly.getLatLngs(), { color: 'red', weight: 3, fill: false }).addTo(highlightGroup);
        highlightLayers.push(highlight);
      }
      const tasksHTML = lotTasksMap[lot].map(t => `- ${t.content} (${t.quantity || ''})`).join('<br>');
      taskListDiv.innerHTML += `<div class="lot-item" data-lot="${lot}"><b>L√¥ ${lot}</b><br>${tasksHTML}</div><hr>`;
    });

    // hover effects (use properties on element to store timers)
    document.querySelectorAll('#taskList .lot-item').forEach(item => {
      item.addEventListener('mouseenter', () => {
        const lotName = item.dataset.lot;
        const basePoly = cropsByName[lotName] || actualByName[lotName] || legalByName[lotName] || disputedByName[lotName];
        if (!basePoly) return;
        const coords = basePoly.getLatLngs();
        item._blinkPoly = L.polygon(coords, { color: 'red', weight: 0, fillColor: 'red', fillOpacity: 0 }).addTo(highlightGroup);
        let visible = false;
        item._blinkId = setInterval(() => { if (item._blinkPoly) item._blinkPoly.setStyle({ fillOpacity: visible ? 0 : 0.4 }); visible = !visible; }, 400);
      });
      item.addEventListener('mouseleave', () => {
        if (item._blinkId) { clearInterval(item._blinkId); item._blinkId = null; }
        if (item._blinkPoly) { highlightGroup.removeLayer(item._blinkPoly); item._blinkPoly = null; }
      });
    });
  }

  // UI elements
  const taskPanel = document.getElementById('taskPanel');
  const taskDateInput = document.getElementById('taskDate');
  const taskListDiv = document.getElementById('taskList');

  document.getElementById('dailyTaskBtn').addEventListener('click', function () {
    drawCrops('all');
    if (!anyLegalChecked() && !map.hasLayer(cropsGroup)) map.addLayer(cropsGroup);
    const now = new Date(); const yyyy = now.getFullYear(); const mm = String(now.getMonth() + 1).padStart(2, '0'); const dd = String(now.getDate()).padStart(2, '0');
    taskDateInput.value = `${yyyy}-${mm}-${dd}`;

    // set title and show panel
    updateTaskPanelTitle(new Date(taskDateInput.value));
    taskDateInput.onchange = () => { updateTaskPanelTitle(new Date(taskDateInput.value)); showTasks(); };
    taskPanel.style.display = 'block'; showTasks();
  });

  document.getElementById('taskDate').addEventListener('change', function () { if (this.value) updateTaskPanelTitle(new Date(this.value)); showTasks(); });
  document.getElementById('closeTasksBtn').addEventListener('click', function () { taskPanel.style.display = 'none'; clearHighlights(); taskListDiv.innerHTML = ''; });

  // crop filter buttons
  document.querySelectorAll('[data-crop]').forEach(btn => btn.addEventListener('click', function () { drawCrops(this.dataset.crop); }));

  // mobile menu open/close (fixed logic)
  document.querySelectorAll('#menu button').forEach(btn => {
    btn.addEventListener('click', function (e) {
      if (window.innerWidth <= 768) {
        const li = this.parentElement;
        document.querySelectorAll('#menu .menu>li').forEach(item => { if (item !== li) item.classList.remove('open'); });
        li.classList.toggle('open');
      }

      if (!this.textContent.includes('Ph√°p l√Ω')) { resetLegalView(); }
    });
  });

  function resetLegalView() {
    ['chkCompanyLegal', 'chkActualLots', 'chkDisputed'].forEach(id => {
      const el = document.getElementById(id);
      el.checked = false;
      el.dispatchEvent(new Event('change'));
    });
  }

  // ----- mobile menu open/close (s·ª≠a logic ƒë·ªÉ ch·ªâ t√°c ƒë·ªông top-level tr√™n mobile)
  const hamburgerBtn = document.getElementById('hamburger');
  hamburgerBtn.addEventListener('click', function(){
  const menuEl = document.querySelector('#menu .menu'); // l·∫•y ƒë√∫ng ul.menu
  menuEl.classList.toggle('show');
  const is = this.getAttribute('aria-expanded') === 'true';
  this.setAttribute('aria-expanded', !is);
});
// ----- ƒê√≥ng menu khi click v√†o b·∫•t k·ª≥ item n√†o (mobile) -----
// ƒê√≥ng menu ch√≠nh khi click v√†o m·ª•c cu·ªëi c√πng
const menuEl = document.querySelector('#menu .menu');
  // ƒê√≥ng menu v√† reset b·∫£n ƒë·ªì khi click n√∫t con (mobile + desktop)
// --- Helper: Update ti√™u ƒë·ªÅ task panel ---
  function updateTaskPanelTitle(selectedDate) {
    if (!selectedDate) return;
    const today = new Date(); today.setHours(0,0,0,0);
    selectedDate.setHours(0,0,0,0);
    const suffix = selectedDate > today ? ' (d·ª± ki·∫øn)' : '';
    const dd = String(selectedDate.getDate()).padStart(2,'0');
    const mm = String(selectedDate.getMonth()+1).padStart(2,'0');
    const yyyy = selectedDate.getFullYear();
    document.getElementById('taskPanelTitle').textContent = 'C√¥ng vi·ªác ng√†y ' + dd + '/' + mm + '/' + yyyy + suffix;
  }

  // --- Top-level menu ---
  document.querySelectorAll('#menu .menu > li > button').forEach(topBtn => {
    topBtn.addEventListener('click', function() {
      const li = this.parentElement;

      // Mobile: toggle submenu
      if (window.innerWidth <= 768) {
        document.querySelectorAll('#menu .menu>li').forEach(item => {
          if (item !== li) item.classList.remove('open');
        });
        li.classList.toggle('open');
      }

      // Top-level kh√°c C√¢y tr·ªìng: reset ph√°p l√Ω + show t·ªïng th·ªÉ
      if (!this.textContent.includes('C√¢y tr·ªìng')) {
        resetLegalView();
        drawCrops('all');
      }
    });
  });

  // --- Submenu items ---
  document.querySelectorAll('#menu .final-item').forEach(subBtn => {
    subBtn.addEventListener('click', function() {
      // Mobile: ·∫©n menu khi click item
      if (window.innerWidth <= 768) {
        menuEl.classList.remove('show');
        hamburgerBtn.setAttribute('aria-expanded','false');
      }

      // Submenu c√¢y tr·ªìng
      if (this.dataset.crop) {
        drawCrops(this.dataset.crop);
      }
      // Submenu c√¥ng vi·ªác h√†ng ng√†y
      if (this.id === 'dailyTaskBtn') {
        const now = new Date();
        const yyyy = now.getFullYear();
        const mm = String(now.getMonth()+1).padStart(2,'0');
        const dd = String(now.getDate()).padStart(2,'0');
        taskDateInput.value = `${yyyy}-${mm}-${dd}`;
        updateTaskPanelTitle(new Date(taskDateInput.value));
        taskDateInput.onchange = () => { updateTaskPanelTitle(new Date(taskDateInput.value)); showTasks(); };
        taskPanel.style.display = 'block';
        showTasks();
      }
    });
  });


  // --- Close task panel ---
  document.getElementById('closeTasksBtn').addEventListener('click', () => {
    taskPanel.style.display = 'none';
    clearHighlights();
    taskListDiv.innerHTML = '';
  });
    const systemColors = {
    "T∆∞·ªõi ch√≠nh": "#FF0000",
    "T∆∞·ªõi nh√°nh": "#1f77b4",
    "T∆∞·ªõi nh√°nh 1": "#2ca02c",
  };
  const pebGroup = L.layerGroup();
  
  const allPipesGroup = L.featureGroup(); // ‚ùó KH√îNG .addTo(map) ·ªü ƒë√¢y
  const pipeGroups = {};
  let irrigationVisible = false;   // tr·∫°ng th√°i ƒëang hi·ªÉn th·ªã hay kh√¥ng
  let layerControl = null;
  let legendControl = null;
  const allPipesPlaceholder = L.layerGroup(); // r·ªóng
    function updateLayerControl(show = true) {
    if (layerControl) {
      map.removeControl(layerControl);
      layerControl = null;
    }
    if (!show) return;
  
    // overlays: placeholder cho "T·∫•t c·∫£ ·ªëng" + t·ª´ng nh√≥m th·ª±c t·∫ø
    const overlays = { "T·∫•t c·∫£ ·ªëng": allPipesPlaceholder };
    Object.keys(pipeGroups).forEach(k => overlays[k] = pipeGroups[k]);
  
    layerControl = L.control.layers(null, overlays, { collapsed: false, position: 'bottomleft' }).addTo(map);
  }
  
  // l·∫Øng nghe khi user tick/un-tick 1 overlay
  map.on('overlayadd', function(e) {
    // n·∫øu user tick "T·∫•t c·∫£ ·ªëng"
    if (e.layer === allPipesPlaceholder) {
      // b·∫≠t t·∫•t c·∫£ nh√≥m con
      Object.values(pipeGroups).forEach(g => { if (!map.hasLayer(g)) map.addLayer(g); });
    } else {
      // user tick 1 nh√≥m con => n·∫øu b√¢y gi·ªù t·∫•t c·∫£ nh√≥m con ƒëang b·∫≠t, check placeholder
      const allOn = Object.values(pipeGroups).every(g => map.hasLayer(g));
      if (allOn && !map.hasLayer(allPipesPlaceholder)) map.addLayer(allPipesPlaceholder);
    }
  });
  
  map.on('overlayremove', function(e) {
    // n·∫øu user un-tick "T·∫•t c·∫£ ·ªëng"
    if (e.layer === allPipesPlaceholder) {
      // t·∫Øt t·∫•t c·∫£ nh√≥m con
      Object.values(pipeGroups).forEach(g => { if (map.hasLayer(g)) map.removeLayer(g); });
    } else {
      // user un-tick 1 nh√≥m con => ch·∫Øc ch·∫Øn placeholder ph·∫£i uncheck
      if (map.hasLayer(allPipesPlaceholder)) map.removeLayer(allPipesPlaceholder);
    }
  });

  function updateLegend(show = true) {
    if (legendControl) map.removeControl(legendControl);
    legendControl = null;
    if (!show) return;
    legendControl = L.control({ position: 'bottomleft' });
    legendControl.onAdd = function() {
      const div = L.DomUtil.create('div', 'pipe-legend');
      div.style.background = 'rgba(255,255,255,0.95)';
      div.style.padding = '8px';
      div.style.borderRadius = '6px';
      div.style.boxShadow = '0 1px 4px rgba(0,0,0,0.2)';
      let html = '<b>Ch√∫ gi·∫£i ·ªëng</b><br/>';
      Object.keys(systemColors).forEach(k => {
        html += `<div style="display:flex;align-items:center;margin:4px 0;">
                   <span style="width:24px;height:6px;display:inline-block;background:${systemColors[k]};margin-right:8px;border-radius:3px"></span>
                   <span>${k}</span>
                 </div>`;
      });
      html += `<div style="display:flex;align-items:center;margin:4px 0;">
                    <span style="width:12px;height:12px;display:inline-block;background:red;margin-right:8px;border-radius:50%;border:1px solid #800"></span>
                    <span>ƒê·∫ßu PEB t∆∞·ªõi</span>
                 </div>`;
      html += `<div style="display:flex;align-items:center;margin:4px 0;">
                    <span style="width:12px;height:12px;display:inline-block;background:blue;margin-right:8px;border-radius:50%;border:1px solid #004"></span>
                    <span>Tr·∫°m b∆°m</span>
                 </div>`;
      div.innerHTML = html;
      return div;
    };
    legendControl.addTo(map);
  }
  function hideLegendAndLayerControl() {
    if (legendControl) map.removeControl(legendControl);
    if (layerControl)  map.removeControl(layerControl);
  }

(function() {
  const sheetUrl = "https://docs.google.com/spreadsheets/d/1-yfsz_JaKXEec14z3ng10q9UgA3BmVTntT5eUq1ItKo/gviz/tq?tqx=out:json";
  const materialStyle = {
    "u_PVC": { dashArray: null },
    "Gang": { dashArray: "6,6" },
    "B√™ t√¥ng": { dashArray: "1,6" }
  };

  // B·∫≠t/t·∫Øt l·ªõp t∆∞·ªõi
  function showIrrigation() {
    if (!map.hasLayer(allPipesGroup)) {
      map.addLayer(allPipesGroup);
      map.addLayer(pebGroup);
    }
  }
  function hideIrrigation() {
    if (map.hasLayer(allPipesGroup)){
      map.removeLayer(allPipesGroup);
      map.removeLayer(pebGroup);
    }
  }

  function parseGviz(text) {
    const match = text.match(/google\.visualization\.Query\.setResponse\((.*)\);/s);
    if (!match) throw new Error("Kh√¥ng parse ƒë∆∞·ª£c response gviz");
    return JSON.parse(match[1]).table.rows;
  }

  function coordsToLatLngs(coordsStr) {
    if (!coordsStr) return [];
    let arr;
    try {
      arr = JSON.parse(coordsStr);
    } catch (e) {
      try {
        const cleaned = coordsStr.replace(/'/g, '"');
        arr = JSON.parse(cleaned);
      } catch (err) {
        console.error("Kh√¥ng parse ƒë∆∞·ª£c toado_polyline:", coordsStr);
        return [];
      }
    }
    return arr.map(pt => L.latLng(Number(pt[0]), Number(pt[1])));
  }

  function diameterToWeight(mm) {
    const d = Number(mm) || 50;
    if (d <= 100) return 2;
    if (d <= 160) return 3;
    if (d <= 250) return 4;
    return 6;
  }

let panelsVisible = false;

document.getElementById("btnTogglePanels").addEventListener("click", function() {
  if (!panelsVisible) {
    updateLegend(true);
    updateLayerControl(true);
    this.innerText = "üìë ·∫®n b·∫£ng";
    panelsVisible = true;
  } else {
    hideLegendAndLayerControl();
    this.innerText = "üìë Hi·ªán b·∫£ng";
    panelsVisible = false;
  }
});


function drawPipes(rows) {
    allPipesGroup.clearLayers();
    Object.values(pipeGroups).forEach(g => g.clearLayers());
    irrigationGroup.clearLayers();   // xo√° c≈©
    pebGroup.clearLayers();
    rows.forEach(r => {
      const cells = r.c || [];
      const id_tuyen   = cells[0]?.v ?? "";
      const he_thong   = cells[1]?.v ?? "Kh√°c";
      const loai_ong   = cells[2]?.v ?? "";
      const duong_kinh_mm = cells[3]?.v ?? "";
      const toado_polyline = cells[4]?.v ?? "";
      const coords = coordsToLatLngs(toado_polyline);
      const latlngs = coordsToLatLngs(toado_polyline);
      if (!pipeGroups[he_thong]) {
        pipeGroups[he_thong] = L.layerGroup();
      }

      const color = systemColors[he_thong] || "#333333";
      const weight = diameterToWeight(duong_kinh_mm);
      const dash = (materialStyle[loai_ong] && materialStyle[loai_ong].dashArray) || null;

      const poly = L.polyline(latlngs, {
          color,
          weight,
          dashArray: dash,
          opacity: 1,
          lineCap: 'round'
      }).addTo(irrigationGroup);
      const center = poly.getBounds().getCenter();
      const tooltip = L.tooltip({
              permanent:true,
              direction:'center',
              className:'pipe-label',
              opacity:0   // ban ƒë·∫ßu ·∫©n
          })
          .setContent(id_tuyen)
          .setLatLng(poly.getBounds().getCenter());
  
          irrigationGroup.addLayer(tooltip);

      const popupHtml = `
        <b>${id_tuyen}</b><br/>
        H·ªá th·ªëng: ${he_thong}<br/>
        V·∫≠t li·ªáu ·ªëng: ${loai_ong || 'N/A'}<br/>
        ƒê∆∞·ªùng k√≠nh: ${duong_kinh_mm ? duong_kinh_mm + ' mm' : 'N/A'}
      `;
      poly.bindPopup(popupHtml);
      poly.addTo(pipeGroups[he_thong]);
      poly.addTo(allPipesGroup);
      // --- V·∫Ω ch·∫•m ƒë·ªè cho "T∆∞·ªõi nh√°nh 1" ---
      if (he_thong === "T∆∞·ªõi nh√°nh 1") {
          const chuyenHuongStr = cells[5]?.v ?? "";
          const chuyenHuong = chuyenHuongStr
              .split(",")
              .map(s => parseInt(s.trim(), 10))
              .filter(n => !isNaN(n));
          const exclude = new Set([0, ...chuyenHuong]);
          // B·ªè k√Ω t·ª± T ƒë·∫ßu ti√™n, gi·ªØ nguy√™n ph·∫ßn c√≤n l·∫°i
          const idPart = id_tuyen.startsWith('T') ? id_tuyen.slice(1) : id_tuyen;
          let stt = 1;  // ƒë·∫øm s·ªë th·ª© t·ª± ƒë·∫ßu peb tr√™n tuy·∫øn
        
          coords.forEach((latlng, idx) => {
              if (!exclude.has(idx)) {
                  const marker = L.circleMarker(latlng, {
                      radius: 6,
                      color: '#ff0000',
                      fillColor: '#ff0000',
                      fillOpacity: 1,
                      weight: 2
                  }).addTo(pebGroup);
                  // T√™n ƒë·∫ßu peb: "P." + (ph·∫ßn sau T) + "." + stt
                  // V√≠ d·ª•: id_tuyen = "T01-1.8", stt = 2 ‚Üí "P.01-1.8.2"
                  const maPeb = `P.${idPart}.${stt}`;
                      marker.bindTooltip(maPeb, {
                      permanent: true,
                      direction: 'center',
                      className: 'peb-label',
                      opacity: 0
                  });
          
                  stt++;
              }
          });
      }
    });
}
    /* ‚úÖ Ch·ªâ thay ƒë·ªïi ƒë·ªô trong su·ªët tooltip khi zoom */
  map.on('zoomend', updateLabelOpacity);

  function updateLabelOpacity() {
      const z = map.getZoom();
      const showZoom = 17;
  
      // --- nh√£n ·ªëng ---
      irrigationGroup.eachLayer(function (layer) {
          if (layer instanceof L.Tooltip) {
              const el = layer.getElement && layer.getElement();
              if (el) {
                  el.style.opacity = (z >= showZoom && pipeLabelVisible) ? 1 : 0;
              }
          }
      });
  
      // --- t√™n PEB ---
      pebGroup.eachLayer(function(layer) {
          layer.setStyle({ opacity: z >= showZoom ? 1 : 0,fillOpacity: z >= showZoom ? 1 : 0 });
          const tt = layer.getTooltip && layer.getTooltip();
          const el = tt && tt.getElement && tt.getElement();
          if (el) {
              el.style.opacity = (z >= showZoom && pebLabelVisible) ? 1 : 0;
          }
      });
  }

  // ‚ùó Ch·ªâ n·∫°p d·ªØ li·ªáu, KH√îNG t·ª± add allPipesGroup
  fetch(sheetUrl).then(r => r.text()).then(text => {
    try {
      const rows = parseGviz(text);
      drawPipes(rows);
    } catch (e) {
      console.error("L·ªói khi x·ª≠ l√Ω sheet ƒë∆∞·ªùng ·ªëng:", e);
    }
  }).catch(err => {
    console.error("L·ªói fetch sheet ƒë∆∞·ªùng ·ªëng:", err);
  });

  window.reloadPipesFromSheet = function(url) {
    const u = url || sheetUrl;
    fetch(u).then(r => r.text()).then(text => {
      try {
        const rows = parseGviz(text);
        drawPipes(rows);
      } catch (e) {
        console.error("L·ªói parse reload:", e);
      }
    }).catch(err => console.error("L·ªói reload:", err));
  };

  // Xu·∫•t public cho menu kh√°c d√πng
  window.showIrrigation = showIrrigation;
  window.hideIrrigation = hideIrrigation;
})();

// N√∫t H·ªá th·ªëng t∆∞·ªõi: click m·ªõi b·∫≠t
// ‚ö†Ô∏è khai b√°o bi·∫øn to√†n c·ª•c


document.getElementById('btnTogglePipeLabel').addEventListener('click', () => {
    pipeLabelVisible = !pipeLabelVisible;
    irrigationGroup.eachLayer(function(layer){
        if (layer instanceof L.Tooltip) {
            const el = layer.getElement && layer.getElement();
            if (el) el.style.opacity = pipeLabelVisible ? 1 : 0;
        }
    });
    document.getElementById('btnTogglePipeLabel').innerText =
        pipeLabelVisible ? "·∫®n nh√£n ·ªëng" : "Hi·ªán nh√£n ·ªëng";
});

document.getElementById('btnTogglePebLabel').addEventListener('click', () => {
    pebLabelVisible = !pebLabelVisible;
    pebGroup.eachLayer(function(layer){
        if (layer.getTooltip) {
            const tt = layer.getTooltip();
            const el = tt && tt.getElement && tt.getElement();
            if (el) el.style.opacity = pebLabelVisible ? 1 : 0;
        }
    });
    document.getElementById('btnTogglePebLabel').innerText =
        pebLabelVisible ? "·∫®n t√™n PEB" : "Hi·ªán t√™n PEB";
});


document.getElementById('btnIrrigation').addEventListener('click', function () {
    // ƒê√≥ng menu mobile nh∆∞ c≈©
    if (window.innerWidth <= 768) {
        menuEl.classList.remove('show');
        hamburgerBtn.setAttribute('aria-expanded', 'false');
    }

    // B·∫≠t / t·∫Øt nh√≥m h·ªá th·ªëng t∆∞·ªõi
     showIrrigation();               // ‚Üê gi·ªØ nguy√™n h√†m c≈© c·ªßa b·∫°n
     map.addLayer(irrigationGroup);  // b·∫≠t to√†n b·ªô layer ·ªëng + nh√£n
     updateLegend(true);     // b·∫≠t ch√∫ gi·∫£i ·ªëng
     updateLayerControl(true); //b·∫≠t qu·∫£n l√Ω hi·ªÉn th·ªã ·ªëng
     if (allPipesGroup.getLayers().length > 0) {
     const bounds = allPipesGroup.getBounds();
     if (bounds.isValid()) map.fitBounds(bounds.pad(0.1));
     document.getElementById('irrigationButtons').style.display = 'block';
    }
});


// C√°c m·ª•c final-item kh√°c: t·∫Øt h·ªá th·ªëng t∆∞·ªõi
// Khi click v√†o b·∫•t k·ª≥ m·ª•c final-item KH√ÅC "H·ªá th·ªëng t∆∞·ªõi" => t·∫Øt nh√≥m ·ªëng t∆∞·ªõi
document.querySelectorAll('#menu .final-item:not(#btnIrrigation)').forEach(subBtn => {
    subBtn.addEventListener('click', function () {

        // üëâ Ch·ªâ t·∫Øt n·∫øu ƒëang b·∫≠t
            map.removeLayer(irrigationGroup);   // ·∫©n to√†n b·ªô tuy·∫øn ·ªëng + nh√£n id_tuyen
            updateLegend(false);        // ·∫©n ch√∫ gi·∫£i ·ªëng
            updateLayerControl(false);    // ·∫©n qu·∫£n l√Ω hi·ªán th·ªã ·ªëng
            hideIrrigation();
            irrigationVisible = false;          // c·∫≠p nh·∫≠t tr·∫°ng th√°i
            document.getElementById('irrigationButtons').style.display = 'none';

        // ƒê√≥ng menu mobile nh∆∞ c≈©
        if (window.innerWidth <= 768) {
            menuEl.classList.remove('show');
            hamburgerBtn.setAttribute('aria-expanded', 'false');
        }
    });
});


};
</script>
</body>
</html>
